---
category: blog
by: Ólafur Páll Geirsson
title: "Update on macros"
---

In September, we shared a
["Roadmap towards non-experimental macros"](http://www.scala-lang.org/blog/2017/10/09/scalamacros.html).
It's been two months now and I'd like to share some a brief update on what has
happened since then.

## The challenge

It is a big undertaking to build a feature rich yet robust macro system that is
portable across multiple compilers (scalac, dotc, intellij-scala) that each
have different internals.
There are not only technical challenges, but also a different views on what
applications Scala macros should primarily enable.
Common use-cases for existing Scala macros include

- code generation, to avoid writing boilerplate by hand, which is
  both error-prone and cumbersome. This is used by [Play JSON] and [Spark].
- embedded DSLs, to attach new semantics to existing language syntax.
  This includes a wide range of appliations from database query
  libraries like [Quill], to hardware construction frameworks like [Chisel] and
  build tools like [sbt].
- optimizations, to avoid expensive runtime allocations and method calls.
  This includes libraries like [spire] and [log4s].
- developer ergnomics, to surface source context information like variable
  names, file names and line numbers. This includes libraries like 
  [ScalaTest] and [sourcecode].
- improved type-safety, to increase the static guarantees of your programs
  beyond what the Scala language can provide. This includes libraries like [Refined].

The current scala-reflect macro system has in fact done a phenomenal job
at accommodating all these diverse use-cases under a unified API.
The Scala ecosystem is as rich as it is thanks to these wide range of applications
enabled by scala-reflect macros.

Each of these applications require different features from a macro system.
For example, code generation macros typically only require inspection on existing types
and creation of new terms, while embedded DSLs require inspection and
transformation of existing terms.
Optimization macros like those in log4s may even be avoided with improvements
to alternative language features like `inline`.

## scala.macros: tagless-final to the rescue
## Unification of LMS and macros
## Squid: reusable and type-safe quasiquotes

[Play JSON]: https://www.playframework.com/documentation/2.6.x/ScalaJsonAutomated
[Circe]: https://circe.github.io/circe/
[Quill]: http://getquill.io/
[Chisel]: https://chisel.eecs.berkeley.edu/
[sbt]: http://www.scala-sbt.org/1.x/docs/Scope-Delegation.html
[log4s]: https://github.com/Log4s/log4s
[spire]: https://github.com/non/spire/
[spire]: https://github.com/non/spire/
[ScalaTest]: http://www.scalatest.org/
[sourcecode]: https://github.com/lihaoyi/sourcecode
[Refined]: https://github.com/fthomas/refined
[Spark]: https://spark.apache.org/sql/



