---
category: blog
by: Ólafur Páll Geirsson
title: "Update on macros"
---

In September, we shared a
["Roadmap towards non-experimental macros"](http://www.scala-lang.org/blog/2017/10/09/scalamacros.html).
It's been two months since then and I'd like to share some a brief update on
what's been happening since then.

## A diverse ecosystem

Macros are used in many different ways.
While exploring the Scala ecosystem, we found a wide range of use-cases for
Scala macro

- code generation, to avoid writing boilerplate by hand, which is
  both error-prone and cumbersome. This is used by [Play JSON] and [Spark].
- embedded DSLs, to attach new semantics to existing language syntax.
  This includes a wide range of applications from database query
  libraries like [Quill], to hardware construction frameworks like [Chisel] and
  build tools like [sbt].
- optimizations, to avoid expensive runtime allocations and method calls.
  This includes libraries like [spire] and [log4s].
- developer ergonomics, to surface source context information like variable
  names, file names and line numbers. This includes libraries like 
  [ScalaTest] and [sourcecode].
- improved type-safety, to increase the static guarantees of your programs
  beyond what the Scala language can provide. This includes libraries like [Refined].

The current scala-reflect macro system has in fact done a phenomenal job
at accommodating all these diverse use-cases under a unified API.
The Scala ecosystem is as rich as it is thanks to these wide range of applications
enabled by scala-reflect macros.

To get a clearer picture of how what macros are most widely used in the
ecosystem, we did an analysis on a corpus of 20.906 source files containing ~3
million lines of code from the Scala compiler community build.
The corpus includes sources for libraries such as ScalaTest, Cats, Scalaz,
Monocle, twitter/util, Spire, Scrooge, Blaze, Algebra, Scanamo as well as
applications code like ornicar/lila (<https://lichess.org>).
We track the number of call-sites to each def macro and group them by whether the call-site comes from test or main sources.
Here are the top results:

```
# Main sources

       443: org.scalactic.source.Position.here()Lorg/scalactic/source/Position;.
       356: org.parboiled2.Parser#rule(Lorg/parboiled2/Rule;)Lorg/parboiled2/Rule;.
       334: spire.syntax.EqOps#`===`(Ljava/lang/Object;Lscala/Predef/$eq$colon$eq;)Z.
       311: spire.syntax.CforSyntax#cfor(Ljava/lang/Object;Lscala/Function1;Lscala/Function1;Lscala/Function1;)V.
       287: akka.parboiled2.Parser#rule(Lakka/parboiled2/Rule;)Lakka/parboiled2/Rule;.
       267: spire.syntax.MultiplicativeSemigroupOps#`*`(Ljava/lang/Object;)Ljava/lang/Object;.
       239: org.scalactic.Requirements#requireNonNull(Lscala/collection/Seq;Lorg/scalactic/Prettifier;Lorg/scalactic/source/Position;)V.
       232: scala.reflect.api.Universe#reify(Ljava/lang/Object;)Lscala/reflect/api/Exprs/Expr;.
       226: spire.syntax.AdditiveSemigroupOps#`+`(Ljava/lang/Object;)Ljava/lang/Object;.
       170: slick.util.MacroSupportInterpolation#b(Lscala/collection/Seq;)V.
       156: reactivemongo.bson.Macros.handler()Lreactivemongo/bson/BSONDocumentReader;.
       152: spire.syntax.CforSyntax#cforRange(Lscala/collection/immutable/Range;Lscala/Function1;)V.
       123: scalaxy.debug.package.require(ZLjava/lang/String;)V.
       110: spire.syntax.MultiplicativeGroupOps#`/`(Ljava/lang/Object;)Ljava/lang/Object;.
       108: play.api.libs.json.Json.format()Lplay/api/libs/json/OFormat;.
       104: scala.StringContext#f(Lscala/collection/Seq;)Ljava/lang/String;.
       102: play.api.libs.json.Json.writes()Lplay/api/libs/json/Writes;.
        98: spire.syntax.AdditiveGroupOps#`unary_-`()Ljava/lang/Object;.
        78: spire.syntax.AdditiveGroupOps#`-`(Ljava/lang/Object;)Ljava/lang/Object;.
        71: play.api.libs.json.Json.reads()Lplay/api/libs/json/Reads;.
        ... truncated

# Test sources

    149421: org.scalactic.source.Position.here()Lorg/scalactic/source/Position;.
    101150: org.scalatest.Assertions#assert(ZLorg/scalactic/Prettifier;Lorg/scalactic/source/Position;)Lorg/scalatest/compatible/Assertion;.
     86533: org.scalatest.LineNumberHelper#thisLineNumber()I.
      2137: org.scalatest.Assertions#assert(ZLjava/lang/Object;Lorg/scalactic/Prettifier;Lorg/scalactic/source/Position;)Lorg/scalatest/compatible/Assertion;.
      1822: minitest.api.Asserts#assertEquals(Ljava/lang/Object;Ljava/lang/Object;)V.
      1553: org.scalatest.DiagrammedAssertions#assert(ZLorg/scalactic/Prettifier;Lorg/scalactic/source/Position;)Lorg/scalatest/compatible/Assertion;.
       786: org.scalatest.Matchers#StringShouldWrapper#shouldNot(Lorg/scalatest/words/CompileWord;Lorg/scalactic/source/Position;)Lorg/scalatest/compatible/Assertion;.
       ... truncated scalatest entries
       390: org.scalactic.Requirements#requireState(ZLjava/lang/Object;Lorg/scalactic/Prettifier;)V.
       390: org.scalactic.Requirements#require(ZLjava/lang/Object;Lorg/scalactic/Prettifier;)V.
       384: minitest.api.Asserts#assert(ZLjava/lang/String;)V.
       376: org.scalactic.Requirements#requireState(ZLorg/scalactic/Prettifier;)V.
       376: org.scalactic.Requirements#require(ZLorg/scalactic/Prettifier;)V.
       358: spire.syntax.EqOps#`===`(Ljava/lang/Object;Lscala/Predef/$eq$colon$eq;)Z.
       322: org.scalatest.Assertions#assertCompiles(Ljava/lang/String;Lorg/scalactic/source/Position;)Lorg/scalatest/compatible/Assertion;.
       307: org.specs2.specification.create.S2StringContextCreation#specificationInStringContext#s2(Lscala/collection/Seq;)Lorg/specs2/specification/core/Fragments;.
       306: scodec.bits.package.HexStringSyntax#hex(Lscala/collection/Seq;)Lscodec/bits/ByteVector;.
       286: org.parboiled2.Parser#rule(Lorg/parboiled2/Rule;)Lorg/parboiled2/Rule;.
       270: spire.syntax.Literals#r()Lspire/math/Rational;.
       256: org.scalatest.Matchers#AnyShouldWrapper#shouldBe(Lorg/scalatest/words/ResultOfATypeInvocation;)Lorg/scalatest/compatible/Assertion;.
       223: org.scalatest.Matchers#StringShouldWrapper#should(Lorg/scalatest/words/CompileWord;Lorg/scalactic/source/Position;)Lorg/scalatest/compatible/Assertion;.
       206: records.Rec.applyDynamic(Ljava/lang/String;Lscala/collection/Seq;)Lrecords/Rec;.
       198: org.scalatest.words.NotWord#be(Lorg/scalatest/words/ResultOfATypeInvocation;)Lorg/scalatest/matchers/Matcher;.
       186: spire.syntax.Literals#b()B.
       ... truncated scalatest entries
        74: minitest.api.Asserts#intercept(Lscala/Function0;)V.
        68: scala.async.Async.async(Lscala/Function0;Lscala/concurrent/ExecutionContext;)Lscala/concurrent/Future;.
        66: spire.syntax.Literals#h()S.
        65: slick.collection.heterogeneous.HList#apply(I)Ljava/lang/Object;.
        63: org.specs2.specification.create.AutoExamples#eg(Lscala/Function0;Lorg/specs2/execute/AsResult;)Lorg/specs2/specification/core/Fragments;.
        60: org.scalatest.matchers.Matcher#OrNotWord#be(Lorg/scalatest/words/ResultOfAnTypeInvocation;)Lorg/scalatest/matchers/Matcher;.
        55: scala.StringContext#f(Lscala/collection/Seq;)Ljava/lang/String;.
        50: org.scalatest.matchers.Matcher#AndNotWord#be(Lorg/scalatest/words/ResultOfAnTypeInvocation;)Lorg/scalatest/matchers/Matcher;.
        50: org.scalatest.matchers.Matcher#AndNotWord#be(Lorg/scalatest/words/ResultOfATypeInvocation;)Lorg/scalatest/matchers/Matcher;.
        46: com.twitter.scalding.serialization.macros.LowerPriorityImplicit#primitiveOrderedBufferSupplier()Lcom/twitter/scalding/serialization/OrderedSerialization;.
        ... truncated
```
The complete list of results can be seen in [this gist](https://gist.github.com/olafurpg/be9d01afab4e2e54e51be620279507aa).
Judging by the numbers, it seems that

- macros are used a lot more in test sources than main sources, which is maybe expected.
- developer ergonomics macros are heavily used in test sources, an order of magnitude more than
  than any other category of macros.
  This may not be surprising since large test suites contain many `assert` calls.
- optimization macros like those in spire/parboiled are widely used.
- code generation macros like JSON.reads/writes are widely used, given that
  they are typically only called them once per type.

One caveat with this study is that the results are heavily biased by the
choice of the corpus, which is predominantly open source libraries.
Please let me know if you would like to add your favorite projects to the corpus or
learn how to run the analysis on a closed source project.
It's quite easy.
A large and representative corpus of "real-world" Scala codebases will help us
continue to use a data-driven approach to prioritize the development of new
macros.

## Tree transformations are tricky

Each of the diverse macro applications listed above require different sets of
features from the macro system.
For example, code generation macros typically only require inspection on existing types
and creation of new terms.
Embedded DSLs on the other hand typically require inspection and transformation of
existing terms created by the compiler.
Optimization macros like those in log4s may even be avoided with improvements
to alternative language features like `inline`.

Some features of the macro system turn out to be relatively simple to support.
In the [scalacenter/macros] repository, we have a prototype macro system
that runs on both Scala 2.x and Dotty.
In only a few days, we got some interesting macros working for both compilers:
a JSON automatic serializer for case classes and most of the [sourcecode] macros.
That pretty exciting news, since that means inspection on types and creation of
new terms doesn't seem to introduce any technical road-blockers!
However, we struggled to implement some other macros like [utest] assert since
it requires the ability to transform trees.

Macros that transform trees produced by the compiler are demanding on the macro
system.
When a term is transformed, the macro library or the macro system must ensure
that internal invariants imposed by the compiler are respcted.
For example, the Scala compiler assumes that typed tree nodes cannot have
untyped children.
In scala-reflect, the burden is on the macro author to ensure this invariant
holds.
Mistakes from mixing untyped and typed tree nodes result in cryptic compiler
crashes.
In the new macro system, we want to avoid exposing such bad experience to macro
authors and library users.

This observation that tree transformation are difficult to support doesn't
imply that new macros won't support them.
It simply means that we need give this problem more time and thought so that we
can come up with a robust solution.
It so happens to be that a PhD student at EPFL, Lionel Parreaux ([@LPTK]),
has been working on the same problem for the past couple years.

## Squid: reusable and type-safe quasiquotes

[Squid] is a metaprogramming framework that facilitates the type-safe
manipulation of Scala programs through quasiquotes.
Unlike scala-reflect quasiquotes, Squid quasiquotes are statically
compiled and guaranteed at macro definition-time to be well-typed, well-scoped
and hygienic.
In addition, Squid quasiquotes are reusable, meaning it's possible to write
generic utility methods, and support more advanced inspection/transformation of
terms/types at macro expansion time.
The properties of Squid quasiquotes make them ideal for robust and safe
transformation of trees.

Squid quasiquotes statically track the context of a quasiquote in its type to
prevent references to unbound identifiers.
For example, `code"(x: Int) + 1"` would be rejected since `x` is undefined.
Instead, quasiquotes must explicitly annotate free variables
using question marks `code"(?x: Int) + 1)` and the context is then tracked in
quasiquote's type `Code[Int, {x: Int]`.
To learn more about Squid works, I highly recommend reading their accepted POPL
2018 paper
["Unifying Analytic and Statically-Typed Quasiquotes"](https://infoscience.epfl.ch/record/232427).

There are still some open problems on how to incorporate Squid with the new macros.
Most notably
- Squid quasiquotes eagerly convert compiler trees to Squid's IR. This may
  introduce problems for some Scala syntax like patterns as well as tree node
  metadata like positions/attachments may get lost.
- Squid currently does not support the ability to defs or classes in quasiquotes.

I believe both of these problems can be addressed with some work, and we are in
discussion with Lionel and his lab about potential collaboration.

## Tagless-final is pretty neat


[Play JSON]: https://www.playframework.com/documentation/2.6.x/ScalaJsonAutomated
[Circe]: https://circe.github.io/circe/
[Quill]: http://getquill.io/
[Chisel]: https://chisel.eecs.berkeley.edu/
[sbt]: http://www.scala-sbt.org/1.x/docs/Scope-Delegation.html
[log4s]: https://github.com/Log4s/log4s
[spire]: https://github.com/non/spire/
[spire]: https://github.com/non/spire/
[ScalaTest]: http://www.scalatest.org/
[sourcecode]: https://github.com/lihaoyi/sourcecode
[Refined]: https://github.com/fthomas/refined
[Spark]: https://spark.apache.org/sql/
[scalacenter/macros]: https://github.com/scalacenter/macros
[utest]: https://github.com/lihaoyi/utest
[Squid]: https://github.com/epfldata/squid/
[@LPTK]: https://github.com/lptk
